                  <meta charset="utf-8">
                  **Report: Final**
            Ben Drews (bfd2@williams.edu)
            Diego Gonzalez (drg4@williams.edu)
            Lylia Li (ll5@williams.edu)
            Youle Chen (yc2@williams.edu)


![Image that sells our project](evocativescene.jpg)

Introduction 
==================================
Our program allows users to edit a scene in real time by adding or removing voxels to the scene. Users can choose from a number of differently colored or textured voxels to add to the scene. Also, users are able to change the color/textures of existing voxels in the scene. Finally, users can apply interesting transformations to the voxels in the scene, like making craters, raising mountains, and digging caves. The program is compatible with virtual reality headsets and controlers, and the user can move around in the scene they created.

Specification
==================================
**Features of the program:**

1. User is able to place and destroy a variety of different voxel types in real time
    - Voxels are 0.5 x 0.5 x 0.5 m
    - Voxels can be added to an unlimited space, but the number of voxels that can be added is capped at 10,000.
    - Models are edited without writing to disk
    - Option to save your model is available

2. Program is compatible with virtual reality headsets and controllers, and the user can move around in 3D space

3. User is able to apply interesting transforms/animations to the voxels in the scene, for example:
    - Making a crater: The user can specify a center and radius and create a crater of depth _____.
    - Raising mountains: The user can specify a center and a height and create a mountain.
    - Creating a shockwave: When a button is pressed, the first hundred voxels in front of the user move up and down in a noisy wave pattern
    - Orbital: Voxels can be removed from the world and start orbiting the user
    - Transforms are animated and do not happen instantaneously (we want to see the mountain being raised)
    - Button user interface (on game controls) that determine what operation we are performing on the scene

4. Selection: User can select groups of voxels
    - Cylinder: The user can specify a center and a radius to select a cylinder of voxels of height ____.
    - Sphere: The user can specify a center and a radius to select a sphere.
    - Box: The user can specify a center and a radius (half an edge length) to select a sphere.
    - Set union: Mode that allows users to add to their current selection.
    - Set intersection: Mode that allows users to select voxels by performing a set intersection with two previous selections.
    - Set minus: Mode that allows users to remove from their current selection.

5. Intersection: User can freely choose the voxel to intersect.
    - Pressing 'f' can switch mode between intersecting the first block from user's view and intersecting based on the intersect distance.
    - Mouse scrolling changes the intersect distance, it affects the intersection method when it does not encounter a block or when it is in the other mode. 

6. Virtual Reality User Interface
    - When you grip the left controller, a control panel with all of the voxel types pops up in the scene in the user's left hand that the user can interact with by pointing at it with the right controller and pulling the trigger

7. Non-VR User Interface
    - Use G3D debug camera for head position
    - User navigates the world by moving the mouse (the camera movements are controlled by the mouse)
    - User places or destroys voxels by left clicking the mouse
    - When you press 'm', a menu with all of the voxel types pops up in the scene that the user can interact with using the mouse

8. Rendering
    - Use G3D built-in renderer: There will be shadows but no indirect lighting

9. Audio
    - Sound effects for placing voxels, removing voxels, transforms, and animations

10. User can import MagicaVoxel objects as templates
    - One model at a time.

**Program evaluation metric:**

1. What is the maximum amount of voxels in the scene before noticeable performance decay?

2. Are the controls intuitive?
    - Survey of other people (Juchan, Tony, other classmates)


Topic Overview 
==================================

Voxel world editors have become quite common since the advent of Minecraft. For our project, we want to use this archetype and combine it with the VR experience. Our goal is to give users the impression that they are shaping the world with their motions. 


Design
==================================

![Call Diagram](callDiagram.png)

**Major functions of App: Voxel geometry**
 Function             | Description                                                
 ---------------------|------------------------------------------------------------
 initializeModel      | Initializes an `ArticulatedModel` that will be edited at runtime when user input is received
 initializeMaterials  | Initializes all of the materials that will be used for each voxel type
 addVoxelModelToScene | Adds a `VisualEntity` to the scene with the voxel ArticulatedModel
 addVoxel             | Based on position and type of voxel received from user input, adds a voxel to the scene by modifying the main `ArticulatedModel`, and updates relevant data structures
 setVoxel             | Finds the given voxel's chunk and sets the voxel type given at the position given
 addVoxelModelToScene | Adds a VisualEntity to the scene with the voxel ArticulatedModel
 addFace              | Adds one face of a voxel given the center of the voxel and a normal
createVoxelGeometry|
createNaiveVoxelGeometry|
 removeVoxel          | Based on position received from user input, removes the voxel at that position from the scene by modifying the main ArticulatedModel, and updates relevant data structures
 unsetVoxel           | Finds the given voxel's chunk and removes the voxel from that chunk
 voxelToWorldSpace / worldToVoxelSpace | Translates between voxel positions and world space positions
 getChunkCoords       | Given a voxel space position, returns the chunk the voxel is located in.
 redrawChunk          | For one chunk, clears the geometries and meshes for each voxel type, and uses the chunk table to repopulate appropriate geomteries and meshes.
 redrawChunks         | Redraws all chunks that have been modified, which are stored in `m_chunksToRedraw`
 redrawWorld          | Redraws all chunks in the scene
 checkBoundaryAdd     | When removing a voxel, checks whether the voxel is in the boundary between two chunks. If it is, pushes neighboring chunks to `m_chunksToRedraw`
importVoxFile         | Given a file source, imports a MagicaVox file into the scene, adds 256 voxel type at the end of the current voxel types.
addColorMaterials     | Given a number, create that number of different colors that are spread out evenly.


**Major functions of App: Applying transforms to voxels**
 Function             | Description                                                
 ---------------------|------------------------------------------------------------
 selectCircle         | Fills the m_selection array with voxels within a given radius of a given point
 elevateSelection     | Moves voxels in the m_selection array up by a given height


**Major functions of App: User interface**
 Function             | Description                                                
 ---------------------|------------------------------------------------------------
 cameraIntersectVoxel | Finds the voxel intersection by ray marching with the ray given by the crosshair object. Returns the voxel and adjacent voxel intersected.
 updateSelect         | Updates the ray of the crosshair object. This is different depending on whether or not vr is enabled
 drawSelectionPreview        | Draws debugSquares in the selected voxel, or a debug sphere over the selected menu item

We use one ArticulatedModel, `m_model`, in the scene to store the geometries and meshes for all of the voxels in the scene. The voxels in the scene are divided into regions called chunks so that when a voxel is deleted in one chunk, only the voxels in that chunk have to be redrawn instead of all of the voxels in the scene. `m_model` has separate geometries and meshes per chunk and material. So even if a grass voxel and a stone voxel are in the same chunk, their vertex and index arrays are stored in different geometries and meshes because they have different materials.

We maintain several data structures to keep track of the voxels in the scene:

- `m_voxToProp` is a Table that maps `int`s that represent each voxel type to `Any` files that contain a list of their properties: material, whether the corners are rounded. *Not yet implemented: transparency, emissivity, if it should have a hit box (tangibility)*.

- `m_voxToMat` is a Table that maps `int`s that represent each voxel type to different materials.

- `m_posToChunk` is a Table that maps voxel positions of voxels in the scene to the chunks they are contained in.

- The chunks are implemented as Tables that map voxel positions of voxels in the scene to voxel  types.

- `m_chunksToRedraw` is an Array that stores chunk positions of chunks that have been changed and need to be redrawn. **TO DO: should we change the name of this?**

- Finally, `m_selection` stores voxel positions of voxels that have been selected in the event of a transform.

When we add a voxel to the scene, first we get the chunk it should be stored in and add it to the chunk. Next, we fetch the geometry and mesh that correspond to the voxel's chunk and type, and add to the CPU vertex and index arrays of the geometry and mesh. We are careful not to add new faces if the pending voxel is adjacent to an existing voxel in the scene. This drastically reduces the number of faces in the scene and ensures that the program does not waste time drawing faces that aren't visible.

When we remove a voxel to the scene, first we get the chunk it is stored in and remove it from the chunk. Next, we fetch the geometry and mesh that correspond to the voxel's chunk and type, and clear the CPU vertex and index arrays of the geometry and mesh. Then, for each type in a chunk, we use the chunk tables to redraw the geometry in that chunk. This is the simplest way to remove voxels because if we just tried to remove one voxel by manually removing that voxel's vertices from the CPU vertex array, then the indexing for all of the other models would be messed up.


Correctness Results
=====================================================

![Scene with each of the different voxel types](voxelTypes.png)

![Scene with non-VR user interface](nonVrMenu.png)

![Scene with VR user interface](vrMenu.png)




Placeholder Quality Images
=====================================================
**Aesthetic goals**
![](1.png width=500px) ![](2.png width=500px)

![](3.png width=500px) ![](4.png width=500px)

**Implementation goals**

[Chunks](http://store.steampowered.com/app/402800/)

[SculptrVR](http://store.steampowered.com/app/418520/)

![](https://www.youtube.com/watch?v=wiz92cCL0m8)

![0:00-0:003: UI goals for VR](https://www.youtube.com/watch?v=qoJzrnNoD5I)

![Template for UI for different colored/textured blocks](5.png)

**Stretch goals**

![Implementing Cube Marching would allow us to render smooth surfaces](6.png)


Evocative Result
==================================
![Evocative result.](evocativescene.jpg)


Schedule
==================================

 Task                 | Description                                                | Date          | 
----------------------|------------------------------------------------------------|--------------:|
 ArticulatedModel     | Get an ArticulatedModel to show up in the scene, be able to add geometry to it at runtime | 11/14 |
 VR Controls          | Learn about how VR controls work and how to get inputs from VR controllers | 11/15 |
 Intersection         | Be able to intersect the scene where the user's mouse is, or where the Virtual Reality controller is | 11/16 |
 Add user input       | Voxels are added on user input (clicking/pressing controller button) | 11/16 |
 Implement removeVoxel | Voxels can be removed from the ArticulatedModel in the scene | 11/16 |
 Basic selection and transform | A cylinder of voxels with set radius can be selected and elevated based on a height determined by user input | 11/17 |
 Materials            | Be able to add voxels of more than one material            |     11/17     |
 Rudimentary GUI      | Debug sphere to show where voxels will be added/removed    |     11/18     |
 Virtual Reality functionality | User input from VR controllers and being able to move around the scene VR | 11/19 |
 Chunking optimization | Divide groups of voxels into different geometries and meshes to speed up program | 11/20 |
 Dynamic selection    | Radius of circle selection is determined by user input     |     11/28     |
 Better VR GUI        | Make Virtual Reality menu look more professional           |     11/30     |
 Selection visualization | Current selection is highlighted                        |     12/1      |
 More materials       | Users can add up to 8 different types of voxels            |     12/1      |
 Add animation interface| Add AnimationControl class, set up data structures       |     12/3      |
 Debug animation interface| Get working animations (crater, shockwave)             |     12/4      |
 Add sound effects    | Different sounds are heard when voxels are placed, removed, or transforms applied | 12/4 |
 Finish up animations |                                                            |     12/5      |
 More materials       | Users can add up to 16 different types of voxels.          |     12/5      |
 Save option          | Add option to save created voxel model to a file           |     12/5      |
 Import worlds        | Add importing worlds feature from Youle's midterm project  |     12/5      |
 Make new scene file  | Have program start in a different scene, not G3D Whiteroom |     12/6      |
 Fix selection options | Union, intersection, difference                           |     12/6      |

**TO DO:**

12/6

- Add importing worlds feature from midterm project (Youle)

- Add option to save model (Youle) (NAH)

- Orbital

- Fix how selection works (Ben) (sphere select is very conservative estimate)

- diego look at where there are TODO comments in the code, please .. thank you

12/7

- Finish report: performance metric, topic overview, screenshots
- Make powerpoint
- Make video (Diego)

Change Log
==================================
1. May have to reconsider max number of voxels in the scene depending on how much optimization we can do
2. May also have to reduce number of materials to choose from depending again on how much faster we can get our program to run
3. Removed "painting voxels" from specification
4. Removed specification bullet where user is able to change how the world is scaled

<!-- Markdeep: -->
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace;}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>