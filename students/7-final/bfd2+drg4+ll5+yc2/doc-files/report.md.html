                  <meta charset="utf-8">
                  **Report: Final**
            Ben Drews (bfd2@williams.edu)
            Diego Gonzalez (drg4@williams.edu)
            Lylia Li (ll5@williams.edu)
            Youle Chen (yc2@williams.edu)

**TO DO:**
- Topic overview (Ben)

- Call diagram (Ben)


![Image that sells our project](evocativescene.jpg)

Introduction 
==================================
Our program allows users to edit a scene in real time by adding or removing voxels to the scene. Users can choose from a number of differently colored or textured voxels to add to the scene. Also, users are able to change the color/textures of existing voxels in the scene. Finally, users can apply interesting transformations to the voxels in the scene, like making craters, raising mountains, and digging caves. The program is compatible with virtual reality headsets and controlers, and the user can move around in the scene they created.

Specification
==================================
**Features of the program:**

1. User is able to place and destroy a variety of different voxel types in real time
    - Voxels are 0.5 x 0.5 x 0.5 m
    - Voxels can be added to an unlimited space, but the number of voxels that can be added is capped at 10,000.
    - Models are edited without writing to disk
    - Option to save your model is available

2. Program is compatible with virtual reality headsets and controllers, and the user can move around in 3D space

3. User is able to apply interesting transforms to the voxels in the scene, for example:
    - Making a crater in the world
    - Raising mountains
    - Digging caves
    - Ideally these wouldn't happen instantaneously (we want to see the mountain being raised)
    - Button user interface (on game controls) that determine what operation we are performing on the scene

4. User is able to change how the world is scaled

5. Virtual Reality User Interface
    - When you grip the left controller, a control panel with all of the voxel types pops up in the scene in the user's left hand that the user can interact with by pointing at it with the right controller and pulling the trigger

6. Non-VR User Interface
    - Use G3D debug camera for head position
    - User navigates the world by moving the mouse (the camera movements are controlled by the mouse)
    - User places or destroys voxels by left clicking the mouse
    - When you press 'p', a control panel with all of the voxel types pops up in the scene that the user can interact with using the mouse

8. Rendering
    - Use G3D built-in renderer: There will be shadows but no indirect lighting

9. Audio
    - Sound effects for placing voxels and destroying voxels

**Stretch goals:**

1. Implement marching cubes algorithm to make smooth surfaces

2. Add physics simulation so we can throw voxels around

3. Import MagicaVoxel objects as templates

4. Make data structures more efficient


**Program evaluation metric:**

1. What is the maximum amount of voxels in the scene before noticeable performance decay?

2. What kinds of transformations can be applied to the scene?

3. Are these transformations easily repeatable? (Are the controls understandable)

Topic Overview 
==================================

Voxel world editors have become quite common since the advent of Minecraft. For our project, we want to use this archetype and combine it with the VR experience. Our goal is to give users the impression that they are shaping the world with their motions. 


Design
==================================

![Call Diagram](callDiagram.png)

**Major functions of App: Voxel geometry**
 Function             | Description                                                
 ---------------------|------------------------------------------------------------
 initializeModel      | Initializes an `ArticulatedModel` that will be edited at runtime when user input is received
 initializeMaterials  | Initializes all of the materials that will be used for each voxel type
 addVoxelModelToScene | Adds a `VisualEntity` to the scene with the voxel ArticulatedModel
 addVoxel             | Based on position and type of voxel received from user input, adds a voxel to the scene by modifying the main `ArticulatedModel`, and updates relevant data structures
 setVoxel             | Finds the given voxel's chunk and sets the voxel type given at the position given
 addVoxelModelToScene | Adds a VisualEntity to the scene with the voxel ArticulatedModel
 addFace              | Adds one face of a voxel given the center of the voxel and a normal
 removeVoxel          | Based on position received from user input, removes the voxel at that position from the scene by modifying the main ArticulatedModel, and updates relevant data structures
 unsetVoxel           | Finds the given voxel's chunk and removes the voxel from that chunk
 voxelToWorldSpace / worldToVoxelSpace | Translates between voxel positions and world space positions
 getChunkCoords       | Given a voxel space position, returns the chunk the voxel is located in.
 redrawChunk          | For one chunk, clears the geometries and meshes for each voxel type, and uses the chunk table to repopulate appropriate geomteries and meshes.
 redrawChunks         | Redraws all chunks that have been modified, which are stored in `m_chunksToRedraw`
 redrawWorld          | Redraws all chunks in the scene
 checkBoundaryAdd     | When removing a voxel, checks whether the voxel is in the boundary between two chunks. If it is, pushes neighboring chunks to `m_chunksToRedraw`


**Major functions of App: Applying transforms to voxels**
 Function             | Description                                                
 ---------------------|------------------------------------------------------------
 selectCircle         | Fills the m_selection array with voxels within a given radius of a given point
 elevateSelection     | Moves voxels in the m_selection array up by a given height


**Major functions of App: User interface**
 Function             | Description                                                
 ---------------------|------------------------------------------------------------
 cameraIntersectVoxel | Finds the voxel intersection by ray marching with the ray given by the crosshair object. Returns the voxel and adjacent voxel intersected.
 updateSelect         | Updates the ray of the crosshair object. This is different depending on whether or not vr is enabled
 drawSelection        | Draws debugSquares in the selected voxel, or a debug sphere over the selected menu item

We use one ArticulatedModel, `m_model`, in the scene to store the geometries and meshes for all of the voxels in the scene. The voxels in the scene are divided into regions called chunks so that when a voxel is deleted in one chunk, only the voxels in that chunk have to be redrawn instead of all of the voxels in the scene. `m_model` has separate geometries and meshes per chunk and material. So even if a grass voxel and a stone voxel are in the same chunk, their vertex and index arrays are stored in different geometries and meshes because they have different materials.

We maintain several data structures to keep track of the voxels in the scene:

- `m_voxToProp` is a Table that maps `int`s that represent each voxel type to `Any` files that contain a list of their properties: material, whether the corners are rounded. *Not yet implemented: transparency, emissivity, if it should have a hit box (tangibility)*.

- `m_voxToMat` is a Table that maps `int`s that represent each voxel type to different materials.

- `m_posToChunk` is a Table that maps voxel positions of voxels in the scene to the chunks they are contained in.

- The chunks are implemented as Tables that map voxel positions of voxels in the scene to voxel  types.

- `m_chunksToRedraw` is an Array that stores chunk positions of chunks that have been changed and need to be redrawn. **TO DO: should we change the name of this?**

- Finally, `m_selection` stores voxel positions of voxels that have been selected in the event of a transform.

When we add a voxel to the scene, first we get the chunk it should be stored in and add it to the chunk. Next, we fetch the geometry and mesh that correspond to the voxel's chunk and type, and add to the CPU vertex and index arrays of the geometry and mesh. We are careful not to add new faces if the pending voxel is adjacent to an existing voxel in the scene. This drastically reduces the number of faces in the scene and ensures that the program does not waste time drawing faces that aren't visible.

When we remove a voxel to the scene, first we get the chunk it is stored in and remove it from the chunk. Next, we fetch the geometry and mesh that correspond to the voxel's chunk and type, and clear the CPU vertex and index arrays of the geometry and mesh. Then, for each type in a chunk, we use the chunk tables to redraw the geometry in that chunk. This is the simplest way to remove voxels because if we just tried to remove one voxel by manually removing that voxel's vertices from the CPU vertex array, then the indexing for all of the other models would be messed up.


Correctness Results
=====================================================

![Scene with each of the different voxel types](voxelTypes.png)

![Scene with non-VR user interface](nonVrMenu.png)

![Scene with VR user interface](vrMenu.png)




Placeholder Quality Images
=====================================================
**Aesthetic goals**
![](1.png width=500px) ![](2.png width=500px)

![](3.png width=500px) ![](4.png width=500px)

**Implementation goals**

[Chunks](http://store.steampowered.com/app/402800/)

[SculptrVR](http://store.steampowered.com/app/418520/)

![](https://www.youtube.com/watch?v=wiz92cCL0m8)

![0:00-0:003: UI goals for VR](https://www.youtube.com/watch?v=qoJzrnNoD5I)

![Template for UI for different colored/textured blocks](5.png)

**Stretch goals**

![Implementing Cube Marching would allow us to render smooth surfaces](6.png)


Evocative Result
==================================
![Evocative result.](evocativescene.jpg)


Schedule
==================================

 Task                 | Description                                                | Date          | 
----------------------|------------------------------------------------------------|--------------:|
 ArticulatedModel     | Get an ArticulatedModel to show up in the scene, be able to add geometry to it at runtime | 11/14 |
 VR Controls          | Learn about how VR controls work and how to get inputs from VR controllers | 11/15 |
 Intersection         | Be able to intersect the scene where the user's mouse is, or where the Virtual Reality controller is | 11/16 |
 Add user input       | Voxels are added on user input (clicking/pressing controller button) | 11/16 |
 Implement removeVoxel | Voxels can be removed from the ArticulatedModel in the scene | 11/16 |
 Basic selection and transform | A cylinder of voxels with set radius can be selected and elevated based on a height determined by user input | 11/17 |
 Materials            | Be able to add voxels of more than one material            |     11/17     |
 Rudimentary GUI      | Debug sphere to show where voxels will be added/removed    |     11/18     |
 Virtual Reality functionality | User input from VR controllers and being able to move around the scene VR | 11/19 |
 Chunking optimization | Divide groups of voxels into different geometries and meshes to speed up program | 11/20 |
 Dynamic selection    | Radius of circle selection is determined by user input     |     11/28     |
 Selection visualization | Current selection is highlighted                        |               |
 Add sound effects    | Different sounds are heard when voxels are placed, removed, or transforms applied |    |
 More materials       | Users can add up to 8 different types of voxels            |               |
 Better VR GUI        | Make Virtual Reality menu look more professional           |               |
 **MAKE POWERPOINT** | **MAKE A POWERPOINT PRESENTATION SO WE ARE NOT EMBARRASSMENTS AT THE FINAL PROJECT PRESENTATIONS** | 12/7 |

**TO DO:**

- More transforms
    - Fill
    - Extrude
    - Crater
    - Mountain

- Fix how selection works (Ben)

- Selection options
    - Sphere
    - Cylinder
    - Box
    - Union
    - Intersection
    - Set minus

- Rename methods (Ben)

- Add sound effects

- Add 8 materials, add more if program doesn't lag, remove some if the program does lag

- Why do we add Point3(0.5, 0.5, 0.5) when getting vox to world space positions?

- Youle: put in importing worlds feature from midterm project

**UI**

- Switch between materials (Diego - working on it, get rid of debug spheres in menu)

    - Highlight the one that's currently selected

- Visualize selections

    - Array of current selections is highlighted/glows

    - **STRETCH GOAL:** Highlight a selection with the VR control laser and have everything in the selection be highlighted (by changing the texture?)

**Speed up**

- Make add voxel method for large sections 

- Remove voxel


Change Log
==================================
1. May have to reconsider max number of voxels in the scene depending on how much optimization we can do
2. May also have to reduce number of materials to choose from depending again on how much faster we can get our program to run
3. Removed "painting voxels" from specification

<!-- Markdeep: -->
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace;}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>